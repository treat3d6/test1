<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Yeat Stats</title>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <style>
        @media (max-width: 640px) {
            .table-container {
                -webkit-overflow-scrolling: touch;
            }
            .modal-content {
                width: 95%;
                max-height: 85vh;
                padding: 1rem;
            }
            .chart-container {
                height: 40vh !important;
            }
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: black;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 1.5rem;
            position: relative;
        }
        .close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }
        .autocomplete-suggestions {
            position: absolute;
            background: black;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            width: calc(100% - 2rem);
            z-index: 1001;
        }
        .suggestion-item {
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
        }
        .suggestion-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .percentage-change {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-black">
    <div id="root"></div>

    <script type="text/babel">
        const YeatStats = () => {
            const [activeTab, setActiveTab] = React.useState('songs');
            const [searchTerm, setSearchTerm] = React.useState('');
            const [sortConfig, setSortConfig] = React.useState({
                key: 'streams',
                direction: 'desc'
            });
            const [songs, setSongs] = React.useState([]);
            const [historyData, setHistoryData] = React.useState({});
            const [albumHistoryData, setAlbumHistoryData] = React.useState({});
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [selectedItems, setSelectedItems] = React.useState([]);
            const [latestDate, setLatestDate] = React.useState(null);
            const [statsData, setStatsData] = React.useState({
                headers: ['Total', 'Lead', 'Solo', 'Features'],
                rows: [
                    { label: 'Streams', values: [0, 0, 0, 0] },
                    { label: 'Daily', values: [0, 0, 0, 0] },
                    { label: 'Tracks', values: [0, 0, 0, 0] }
                ]
            });

            const [albums, setAlbums] = React.useState([
                { title: "Up 2 Më", streams: 0, daily: 0, tracks: 0 },
                { title: "Lyfë", streams: 0, daily: 0, tracks: 0 },
                { title: "2 Alivë", streams: 0, daily: 0, tracks: 0 },
                { title: "2093", streams: 0, daily: 0, tracks: 0 },
                { title: "AftërLyfe", streams: 0, daily: 0, tracks: 0 },
                { title: "4L", streams: 0, daily: 0, tracks: 0 },
                { title: "Trëndi", streams: 0, daily: 0, tracks: 0 },
                { title: "Alivë", streams: 0, daily: 0, tracks: 0 },
                { title: "LYFESTYLE", streams: 0, daily: 0, tracks: 0 }
            ]);

            React.useEffect(() => {
                setHistoryData({});
                setAlbumHistoryData({});
                loadAllData();
            }, []);

            const loadAllData = async () => {
                try {
                    setLoading(true);
                    setError(null);

                    const rawHistory = {};
                    const rawAlbumHistory = {};
                    let earliestDate = null;
                    let latestDate = null;
                    let latestResponse = null;
                    let fileCount = 0;
                    const processedDates = [];

                    const startDate = new Date('2025-01-01');
                    const endDate = new Date();
                    const today = new Date();

                    let dateIterator = new Date(startDate);
                    while (dateIterator <= endDate) {
                        const dateStr = dateIterator.toISOString().split('T')[0];
                        try {
                            const currentDate = new Date(dateStr);
                            if (currentDate > today) {
                                console.log(`Skipping future date: ${dateStr}`);
                                dateIterator.setDate(dateIterator.getDate() + 1);
                                continue;
                            }

                            const response = await fetch(`./${dateStr}.csv?t=${Date.now()}`, {
                                cache: 'no-store'
                            });
                            if (response.ok) {
                                const text = await response.text();
                                const parsedData = await new Promise((resolve, reject) => {
                                    Papa.parse(text, {
                                        header: true,
                                        skipEmptyLines: true,
                                        transformHeader: header => header.trim(),
                                        complete: (results) => resolve(results.data),
                                        error: (err) => reject(err)
                                    });
                                });

                                parsedData.forEach(row => {
                                    const title = row.Song || '';
                                    const album = row.Album || '';
                                    const daily = parseInt((row['Spotify daily'] || '').replace(/,/g, '')) || null;
                                    const total = parseInt((row['Spotify total'] || '').replace(/,/g, '')) || null;
                                    if (title && album && daily !== null && total !== null) {
                                        const songKey = title.toLowerCase() === 'already rich' ? 'Already Rich' : `${title}|${album}`;
                                        if (!rawHistory[songKey]) {
                                            rawHistory[songKey] = [];
                                        }
                                        rawHistory[songKey].push({
                                            date: dateStr,
                                            streams: total,
                                            daily: daily,
                                            album: album
                                        });

                                        if (!rawAlbumHistory[album]) {
                                            rawAlbumHistory[album] = [];
                                        }
                                        const existingAlbumEntry = rawAlbumHistory[album].find(e => e.date === dateStr);
                                        if (existingAlbumEntry) {
                                            existingAlbumEntry.streams += total;
                                            existingAlbumEntry.daily += daily;
                                        } else {
                                            rawAlbumHistory[album].push({
                                                date: dateStr,
                                                streams: total,
                                                daily: daily
                                            });
                                        }
                                    }
                                });

                                fileCount++;
                                processedDates.push(dateStr);
                                if (!earliestDate || dateStr < earliestDate) {
                                    earliestDate = dateStr;
                                }
                                if (!latestDate || dateStr > latestDate) {
                                    latestDate = dateStr;
                                    latestResponse = { ok: true, text: () => Promise.resolve(text) };
                                }
                            } else {
                                console.warn(`CSV file for ${dateStr} not found (status: ${response.status})`);
                            }
                        } catch (err) {
                            console.warn(`Failed to load ${dateStr}.csv: ${err.message}`);
                        }
                        dateIterator.setDate(dateIterator.getDate() + 1);
                    }

                    if (!latestResponse) {
                        throw new Error('No CSV files found in the repository.');
                    }

                    const history = {};
                    Object.keys(rawHistory).forEach(key => {
                        history[key] = rawHistory[key].sort((a, b) => new Date(a.date) - new Date(b.date));
                    });

                    const albumHistory = {};
                    Object.keys(rawAlbumHistory).forEach(key => {
                        albumHistory[key] = rawAlbumHistory[key].sort((a, b) => new Date(a.date) - new Date(b.date));
                    });

                    console.log(`Processed ${fileCount} CSV files. Dates: ${processedDates.sort().join(', ')}`);

                    const latestText = await latestResponse.text();
                    processCSVData(latestText);
                    setHistoryData(history);
                    setAlbumHistoryData(albumHistory);
                    setLatestDate(latestDate);
                } catch (error) {
                    console.error('Error loading data:', error);
                    setError(error.message);
                } finally {
                    setLoading(false);
                }
            };

            const processCSVData = (csvText) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    transformHeader: header => header.trim(),
                    complete: (results) => {
                        if (!results.data || results.data.length === 0) {
                            setError('No data found in CSV');
                            return;
                        }

                        const songMap = {};
                        results.data.forEach(row => {
                            const title = row.Song || '';
                            const album = row.Album || '';
                            const daily = parseInt((row['Spotify daily'] || '0').replace(/,/g, '')) || 0;
                            if (title) {
                                const key = title.toLowerCase() === 'already rich' ? 'Already Rich' : `${title}|${album}`;
                                if (!songMap[key]) {
                                    songMap[key] = {
                                        title: title.toLowerCase() === 'already rich' ? 'Already Rich' : title,
                                        album: album,
                                        streams: 0,
                                        daily: 0
                                    };
                                }
                                songMap[key].streams += parseInt((row['Spotify total'] || '0').replace(/,/g, '')) || 0;
                                songMap[key].daily += daily;
                            }
                        });

                        const processedSongs = Object.values(songMap).filter(song => song.streams || song.daily);
                        setSongs(processedSongs);
                        calculateStats(processedSongs);
                    },
                    error: (error) => {
                        setError('Error parsing CSV: ' + error.message);
                    }
                });
            };

            const calculateStats = (processedSongs) => {
                const totalStreams = processedSongs.reduce((sum, song) => sum + song.streams, 0);
                const totalDaily = processedSongs.reduce((sum, song) => sum + song.daily, 0);
                const totalTracks = processedSongs.length;

                const featureTracks = processedSongs.filter(song => song.album === "Features");
                const featureStreams = featureTracks.reduce((sum, song) => sum + song.streams, 0);
                const featureDaily = featureTracks.reduce((sum, song) => sum + song.daily, 0);
                const featureCount = featureTracks.length;

                const leadTracks = processedSongs.filter(song => song.album !== "Features");
                const leadStreams = leadTracks.reduce((sum, song) => sum + song.streams, 0);
                const leadDaily = leadTracks.reduce((sum, song) => sum + song.daily, 0);
                const leadCount = leadTracks.length;

                const soloTracks = leadTracks.filter(song => !song.title.toLowerCase().includes("feat."));
                const soloStreams = soloTracks.reduce((sum, song) => sum + song.streams, 0);
                const soloDaily = soloTracks.reduce((sum, song) => sum + song.daily, 0);
                const soloCount = soloTracks.length;

                setStatsData({
                    headers: statsData.headers,
                    rows: [
                        { label: 'Streams', values: [totalStreams, leadStreams, soloStreams, featureStreams] },
                        { label: 'Daily', values: [totalDaily, leadDaily, soloDaily, featureDaily] },
                        { label: 'Tracks', values: [totalTracks, leadCount, soloCount, featureCount] }
                    ]
                });

                const albumStats = albums.map(album => {
                    const albumSongs = processedSongs.filter(song => song.album === album.title);
                    return {
                        title: album.title,
                        streams: albumSongs.reduce((sum, song) => sum + song.streams, 0),
                        daily: albumSongs.reduce((sum, song) => sum + song.daily, 0),
                        tracks: albumSongs.length
                    };
                });
                setAlbums(albumStats);
            };

            const ComparisonChart = ({ itemKeys, itemsData, historyData, isAlbum, onClose }) => {
                const chartRef = React.useRef(null);
                const canvasRef = React.useRef(null);
                const [dateRange, setDateRange] = React.useState('all');
                const [customStartDate, setCustomStartDate] = React.useState('');
                const [customEndDate, setCustomEndDate] = React.useState('');
                const [tempStartDate, setTempStartDate] = React.useState('');
                const [tempEndDate, setTempEndDate] = React.useState('');
                const [showCustomPicker, setShowCustomPicker] = React.useState(false);
                const [chartError, setChartError] = React.useState(null);
                const [compareItems, setCompareItems] = React.useState(itemKeys);
                const [searchCompare, setSearchCompare] = React.useState('');
                const [showSuggestions, setShowSuggestions] = React.useState(false);
                const [dateLabels, setDateLabels] = React.useState([]);

                const colors = [
                    '#60A5FA', '#F87171', '#34D399', '#FBBF24', '#A78BFA',
                    '#EC4899', '#10B981', '#F59E0B', '#8B5CF6', '#EF4444'
                ];

                const validateDates = (start, end, histories) => {
                    if (!start || !end || !histories || !histories.length) return false;
                    try {
                        const startDate = new Date(start);
                        const endDate = new Date(end);
                        if (isNaN(startDate) || isNaN(endDate) || startDate > endDate) return false;

                        return histories.every(history => {
                            if (!history || !history.length) return false;
                            const minDate = new Date(history[0].date);
                            const maxDate = new Date(history[history.length - 1].date);
                            return startDate >= minDate && endDate <= maxDate;
                        });
                    } catch (e) {
                        console.error('Date validation error:', e);
                        return false;
                    }
                };

                const handleApplyCustomDates = () => {
                    const histories = compareItems.map(key => historyData[key]).filter(Boolean);
                    if (validateDates(tempStartDate, tempEndDate, histories)) {
                        setCustomStartDate(tempStartDate);
                        setCustomEndDate(tempEndDate);
                        setChartError(null);
                    } else {
                        setChartError('Invalid date range. Please select dates within the available data.');
                    }
                };

                const handleItemSelect = (key) => {
                    if (!compareItems.includes(key) && compareItems.length < 5) {
                        const newCompareItems = [...compareItems, key];
                        setCompareItems(newCompareItems);
                        setSearchCompare('');
                        setShowSuggestions(false);

                        const histories = newCompareItems.map(k => historyData[k]).filter(Boolean);
                        if (customStartDate && customEndDate && !validateDates(customStartDate, customEndDate, histories)) {
                            setCustomStartDate('');
                            setCustomEndDate('');
                            setTempStartDate('');
                            setTempEndDate('');
                            setDateRange('all');
                            setShowCustomPicker(false);
                        }
                    }
                };

                const handleItemRemove = (key) => {
                    const newCompareItems = compareItems.filter(k => k !== key);
                    setCompareItems(newCompareItems);

                    const histories = newCompareItems.map(k => historyData[k]).filter(Boolean);
                    if (customStartDate && customEndDate && !validateDates(customStartDate, customEndDate, histories)) {
                        setCustomStartDate('');
                        setCustomEndDate('');
                        setTempStartDate('');
                        setTempEndDate('');
                        setDateRange('all');
                        setShowCustomPicker(false);
                    }
                };

                const filteredItems = itemsData.filter(item => 
                    item.title.toLowerCase().includes(searchCompare.toLowerCase()) &&
                    !compareItems.includes(isAlbum ? item.title : (item.title.toLowerCase() === 'already rich' ? 'Already Rich' : `${item.title}|${item.album}`))
                );

                const calculateOverallPercentageChange = (history, dateLabels) => {
                    if (!history || history.length < 1 || !dateLabels || dateLabels.length < 1) return null;
                    const firstDate = new Date(dateLabels[0]);
                    const lastDate = new Date(dateLabels[dateLabels.length - 1]);
                    const firstEntry = history.find(e => new Date(e.date).toDateString() === firstDate.toDateString());
                    const lastEntry = history.find(e => new Date(e.date).toDateString() === lastDate.toDateString());
                    const firstDaily = firstEntry ? firstEntry.daily || 0 : 0;
                    const lastDaily = lastEntry ? lastEntry.daily || 0 : 0;

                    if (firstDaily === 0 && lastDaily === 0) return '0.00';
                    if (firstDaily === 0 && lastDaily !== 0) return 'N/A (First day was 0)';
                    if (firstDaily !== 0) {
                        const change = ((lastDaily - firstDaily) / firstDaily) * 100;
                        return change.toFixed(2);
                    }
                    return null;
                };

                React.useEffect(() => {
                    if (!historyData || Object.keys(historyData).length === 0 || !compareItems.length) {
                        setChartError('No data available for comparison.');
                        setDateLabels([]);
                        return;
                    }

                    try {
                        const allItemDates = new Set();
                        compareItems.forEach(key => {
                            const history = historyData[key] || [];
                            history.forEach(entry => allItemDates.add(entry.date));
                        });

                        let minDate = null;
                        let maxDate = null;
                        compareItems.forEach(key => {
                            const history = historyData[key] || [];
                            if (history.length) {
                                const firstDate = new Date(history[0].date);
                                const lastDate = new Date(history[history.length - 1].date);
                                minDate = minDate ? new Date(Math.min(minDate, firstDate)) : firstDate;
                                maxDate = maxDate ? new Date(Math.max(maxDate, lastDate)) : lastDate;
                            }
                        });

                        let startDate, endDate;
                        const histories = compareItems.map(key => historyData[key]).filter(Boolean);
                        if (dateRange === 'custom' && customStartDate && customEndDate && 
                            validateDates(customStartDate, customEndDate, histories)) {
                            startDate = new Date(customStartDate);
                            endDate = new Date(customEndDate);
                        } else {
                            endDate = maxDate;
                            if (dateRange === 'all') {
                                startDate = minDate;
                            } else {
                                const days = parseInt(dateRange) || 7;
                                startDate = new Date(endDate);
                                startDate.setDate(endDate.getDate() - days + 1);
                            }
                        }

                        const newDateLabels = Array.from(allItemDates)
                            .filter(date => {
                                const d = new Date(date);
                                return d >= startDate && d <= endDate;
                            })
                            .sort((a, b) => new Date(a) - new Date(b));

                        if (newDateLabels.length === 0) {
                            setChartError('No data available for the selected date range.');
                            setDateLabels([]);
                            return;
                        }

                        const allLabels = newDateLabels.map(date => {
                            const d = new Date(date);
                            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' });
                        });

                        const datasets = compareItems.map((key, index) => {
                            const history = historyData[key] || [];
                            if (!history.length) return null;

                            const label = isAlbum ? key : (() => {
                                const [title, album] = key.split('|');
                                return `${title.toLowerCase() === 'already rich' ? 'Already Rich' : title} (${album})`;
                            })();

                            const dailyData = newDateLabels.map(date => {
                                const entry = history.find(e => e.date === date);
                                return entry ? entry.daily : null;
                            });

                            return {
                                label,
                                data: dailyData,
                                borderColor: colors[index % colors.length],
                                backgroundColor: colors[index % colors.length] + '33',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 0,
                                borderWidth: 2,
                                spanGaps: true
                            };
                        }).filter(ds => ds !== null);

                        if (!allLabels.length || !datasets.length) {
                            setChartError('No data available for the selected date range.');
                            setDateLabels([]);
                            return;
                        }

                        const ctx = canvasRef.current?.getContext('2d');
                        if (!ctx) {
                            setChartError('Failed to initialize chart.');
                            setDateLabels([]);
                            return;
                        }

                        if (chartRef.current) {
                            chartRef.current.destroy();
                        }

                        chartRef.current = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: allLabels,
                                datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        ticks: {
                                            color: '#ffffff',
                                            font: { size: 12 },
                                            maxRotation: 45,
                                            minRotation: 45
                                        },
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                                    },
                                    y: {
                                        title: { display: false },
                                        ticks: {
                                            color: '#ffffff',
                                            font: { size: 12 },
                                            callback: (value) => value ? value.toLocaleString() : ''
                                        },
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        beginAtZero: true
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top',
                                        labels: {
                                            color: '#ffffff',
                                            font: { size: 12 }
                                        }
                                    },
                                    title: { display: false },
                                    tooltip: {
                                        enabled: true,
                                        backgroundColor: '#1f2937',
                                        titleColor: '#ffffff',
                                        bodyColor: '#ffffff',
                                        borderColor: '#4b5563',
                                        borderWidth: 1,
                                        cornerRadius: 4,
                                        displayColors: true,
                                        callbacks: {
                                            label: (context) => {
                                                const datasetIndex = context.datasetIndex;
                                                const dataIndex = context.dataIndex;
                                                const key = compareItems[datasetIndex];
                                                const history = historyData[key] || [];
                                                const date = newDateLabels[dataIndex];
                                                const entry = history.find(e => e.date === date);
                                                return [
                                                    `Daily: ${context.parsed.y?.toLocaleString() || 'N/A'}`,
                                                    `Total: ${entry?.streams?.toLocaleString() || 'N/A'}`
                                                ];
                                            }
                                        }
                                    }
                                },
                                interaction: {
                                    intersect: false,
                                    mode: 'nearest',
                                    axis: 'x'
                                }
                            }
                        });

                        setChartError(null);
                        setDateLabels(newDateLabels);

                    } catch (e) {
                        console.error('Chart rendering error:', e.message, e.stack);
                        setChartError('Failed to render chart. Please try again.');
                        setDateLabels([]);
                    }
                }, [compareItems, dateRange, customStartDate, customEndDate, historyData, isAlbum]);

                const getDateRangeText = () => {
                    if (!compareItems.length || compareItems.some(key => !historyData[key] || !historyData[key].length)) 
                        return 'No data available';

                    let minDate = null;
                    let maxDate = null;
                    compareItems.forEach(key => {
                        const history = historyData[key] || [];
                        if (history.length) {
                            const firstDate = new Date(history[0].date);
                            const lastDate = new Date(history[history.length - 1].date);
                            minDate = minDate ? new Date(Math.min(minDate, firstDate)) : firstDate;
                            maxDate = maxDate ? new Date(Math.max(maxDate, lastDate)) : lastDate;
                        }
                    });

                    if (!minDate || !maxDate) return 'No data available';

                    let startDate, endDate;
                    const histories = compareItems.map(key => historyData[key]).filter(Boolean);
                    if (dateRange === 'custom' && customStartDate && customEndDate && 
                        validateDates(customStartDate, customEndDate, histories)) {
                        startDate = new Date(customStartDate);
                        endDate = new Date(customEndDate);
                    } else {
                        endDate = maxDate;
                        if (dateRange === 'all') {
                            startDate = minDate;
                        } else {
                            const days = parseInt(dateRange) || 7;
                            startDate = new Date(endDate);
                            startDate.setDate(endDate.getDate() - days + 1);
                        }
                    }

                    return `${startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' })} - ${endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' })}`;
                };

                const showPercentageChange = compareItems.length === 1 && dateRange !== 'all';
                const percentageChange = showPercentageChange && dateLabels.length > 0 
                    ? calculateOverallPercentageChange(historyData[compareItems[0]] || [], dateLabels) 
                    : null;
                const changeColor = percentageChange && percentageChange !== 'N/A (First day was 0)' && percentageChange !== '0.00' 
                    ? parseFloat(percentageChange) >= 0 ? 'text-green-500' : 'text-red-500'
                    : 'text-white';

                return (
                    <div className="modal-overlay" onClick={onClose}>
                        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                            <button className="close-button" onClick={onClose}>
                                ×
                            </button>
                            <div className="mb-4">
                                <h2 className="text-lg font-bold text-white sm:text-xl">
                                    Compare {isAlbum ? 'Albums' : 'Songs'}
                                </h2>
                                <div className="mt-2 relative">
                                    <input
                                        type="text"
                                        placeholder={`Search ${isAlbum ? 'albums' : 'songs'} to compare...`}
                                        className="w-full px-4 py-2 text-sm rounded-lg border border-white/20 bg-black text-white placeholder-white/40 focus:outline-none focus:border-white/40 mb-2"
                                        value={searchCompare}
                                        onChange={(e) => {
                                            setSearchCompare(e.target.value);
                                            setShowSuggestions(e.target.value.length > 0);
                                        }}
                                        onFocus={() => setShowSuggestions(searchCompare.length > 0)}
                                        onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
                                    />
                                    {showSuggestions && filteredItems.length > 0 && (
                                        <div className="autocomplete-suggestions">
                                            {filteredItems.map(item => {
                                                const key = isAlbum ? item.title : (item.title.toLowerCase() === 'already rich' ? 'Already Rich' : `${item.title}|${item.album}`);
                                                return (
                                                    <div
                                                        key={key}
                                                        className="suggestion-item text-sm"
                                                        onClick={() => handleItemSelect(key)}
                                                    >
                                                        {isAlbum ? item.title : `${item.title} (${item.album})`}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                    <div className="flex flex-wrap gap-2 mt-2">
                                        {compareItems.map(key => (
                                            <div
                                                key={key}
                                                className="flex items-center px-3 py-1 text-sm bg-white/20 text-white rounded-full"
                                            >
                                                {isAlbum ? key : (() => {
                                                    const [title, album] = key.split('|');
                                                    return `${title} (${album})`;
                                                })()}
                                                <button
                                                    className="ml-2 text-white/60 hover:text-white"
                                                    onClick={() => handleItemRemove(key)}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                    {compareItems.length >= 5 && (
                                        <p className="text-sm text-yellow-500 mt-2">
                                            Maximum 5 {isAlbum ? 'albums' : 'songs'} can be compared
                                        </p>
                                    )}
                                </div>
                                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mt-4 gap-2">
                                    <div>
                                        <p className="text-sm text-white/60">{getDateRangeText()}</p>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        {['7', '28', '90', 'all'].map(range => (
                                            <button
                                                key={range}
                                                className={`px-3 py-1 text-sm rounded-full border ${dateRange === range ? 'bg-white/20 border-white/40' : 'border-white/20'} text-white hover:bg-white/10`}
                                                onClick={() => {
                                                    setDateRange(range);
                                                    setShowCustomPicker(false);
                                                    setCustomStartDate('');
                                                    setCustomEndDate('');
                                                    setTempStartDate('');
                                                    setTempEndDate('');
                                                }}
                                            >
                                                {range === 'all' ? 'All' : `Last ${range} days`}
                                            </button>
                                        ))}
                                        <button
                                            className={`px-3 py-1 text-sm rounded-full border ${dateRange === 'custom' ? 'bg-white/20 border-white/40' : 'border-white/20'} text-white hover:bg-white/10`}
                                            onClick={() => {
                                                setDateRange('custom');
                                                setShowCustomPicker(true);
                                                setTempStartDate('');
                                                setTempEndDate('');
                                            }}
                                        >
                                            Custom
                                        </button>
                                    </div>
                                </div>
                                {showCustomPicker && dateRange === 'custom' && (
                                    <div className="mt-4 flex flex-col sm:flex-row gap-4 items-start sm:items-center">
                                        <div className="flex flex-col w-full sm:w-auto">
                                            <label className="text-sm text-white/60">Start Date:</label>
                                            <input
                                                type="date"
                                                className="mt-1 px-3 py-1 text-sm rounded-lg border border-white/20 bg-black text-white focus:outline-none focus:border-white/40 w-full"
                                                value={tempStartDate}
                                                onChange={(e) => setTempStartDate(e.target.value)}
                                            />
                                        </div>
                                        <div className="flex flex-col w-full sm:w-auto">
                                            <label className="text-sm text-white/60">End Date:</label>
                                            <input
                                                type="date"
                                                className="mt-1 px-3 py-1 text-sm rounded-lg border border-white/20 bg-black text-white focus:outline-none focus:border-white/40 w-full"
                                                value={tempEndDate}
                                                onChange={(e) => setTempEndDate(e.target.value)}
                                            />
                                        </div>
                                        <button
                                            className="px-4 py-1 text-sm rounded-lg border border-white/20 bg-black text-white hover:bg-white/10 mt-4 sm:mt-0 sm:ml-2"
                                            onClick={handleApplyCustomDates}
                                        >
                                            Apply
                                        </button>
                                    </div>
                                )}
                                {chartError && (
                                    <div className="mt-4 text-sm text-red-500">
                                        {chartError}
                                    </div>
                                )}
                            </div>
                            {!chartError && (
                                <div className="chart-container h-[40vh] sm:h-[45vh]">
                                    <canvas ref={canvasRef}></canvas>
                                </div>
                            )}
                            {showPercentageChange && percentageChange !== null && (
                                <div className={`percentage-change ${changeColor}`}>
                                    <h3 className="font-bold mb-2">Overall Percentage Change</h3>
                                    <p>{percentageChange}%</p>
                                </div>
                            )}
                        </div>
                    </div>
                );
            };

            const formatNumber = (num) => num.toLocaleString('en-US');

            const formatDate = (dateStr) => {
                if (!dateStr) return '';
                const [year, month, day] = dateStr.split('-');
                return `${parseInt(month)}/${parseInt(day)}/${year.slice(2)}`;
            };

            const requestSort = (key) => {
                let direction = 'desc';
                if (sortConfig.key === key && sortConfig.direction === 'desc') {
                    direction = 'asc';
                }
                setSortConfig({ key, direction });
            };

            const getSortedData = (data) => {
                if (!sortConfig.key) return data;

                return [...data].sort((a, b) => {
                    if (sortConfig.key === 'title' || sortConfig.key === 'album') {
                        const aValue = a[sortConfig.key] || '';
                        const bValue = b[sortConfig.key] || '';
                        if (sortConfig.direction === 'asc') {
                            return aValue.localeCompare(bValue);
                        }
                        return bValue.localeCompare(aValue);
                    }
                    if (sortConfig.direction === 'asc') {
                        return a[sortConfig.key] - b[sortConfig.key];
                    }
                    return b[sortConfig.key] - a[sortConfig.key];
                });
            };

            const filteredData = {
                songs: getSortedData(songs.filter(song => 
                    song.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    song.album.toLowerCase().includes(searchTerm.toLowerCase())
                )),
                albums: getSortedData(albums.filter(album =>
                    album.title.toLowerCase().includes(searchTerm.toLowerCase())
                ))
            };

            const getSortIndicator = (key) => {
                if (sortConfig.key === key) {
                    return sortConfig.direction === 'asc' ? ' ↑' : ' ↓';
                }
                return '';
            };

            const handleItemClick = (item) => {
                const key = activeTab === 'songs' 
                    ? (item.title.toLowerCase() === 'already rich' ? 'Already Rich' : `${item.title}|${item.album}`)
                    : item.title;
                setSelectedItems(prev => prev.includes(key) ? prev : [...prev, key]);
            };

            return (
                <div className="w-full max-w-6xl mx-auto p-2 sm:p-6">
                    <div className="bg-black border border-white/10 rounded-lg shadow-2xl p-3 sm:p-6">
                        <div className="mb-4 sm:mb-8">
                            <h1 className="text-xl sm:text-2xl font-bold mb-2 text-white">Yeat Spotify Stats</h1>
                            <p className="text-xs sm:text-sm text-white/60">
                                {formatDate(latestDate)}
                            </p>
                            {error && (
                                <div className="mt-2 text-sm text-red-500">
                                    Error: {error}
                                </div>
                            )}
                        </div>

                        {loading ? (
                            <div className="text-center py-8 text-white/60">
                                Loading data... Please wait.
                            </div>
                        ) : (
                            <>
                                <div className="overflow-x-auto mb-4 sm:mb-8 table-container">
                                    <table className="min-w-full">
                                        <thead>
                                            <tr>
                                                <th className="text-left px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80"></th>
                                                {statsData.headers.map((header, index) => (
                                                    <th key={index} className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">{header}</th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {statsData.rows.map((row, index) => (
                                                <tr key={index} className={index % 2 === 0 ? 'bg-black' : 'bg-white/5'}>
                                                    <td className="px-2 sm:px-4 py-2 text-xs sm:text-sm font-medium text-white/80">{row.label}</td>
                                                    {row.values.map((value, valueIndex) => (
                                                        <td key={valueIndex} className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">
                                                            {formatNumber(value)}
                                                        </td>
                                                    ))}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>

                                <div className="flex flex-col sm:flex-row justify-between items-stretch sm:items-center mb-4 sm:mb-6 gap-3">
                                    <div className="flex gap-2 sm:gap-4">
                                        <button 
                                            className={`flex-1 sm:flex-none px-4 sm:px-6 py-2 text-sm font-medium rounded-lg transition-colors ${
                                                activeTab === 'songs' 
                                                ? 'bg-white text-black' 
                                                : 'bg-black text-white/80 border border-white/20 hover:bg-white/10'
                                            }`}
                                            onClick={() => {
                                                setActiveTab('songs');
                                                setSelectedItems([]);
                                            }}
                                        >
                                            Songs
                                        </button>
                                        <button 
                                            className={`flex-1 sm:flex-none px-4 sm:px-6 py-2 text-sm font-medium rounded-lg transition-colors ${
                                                activeTab === 'albums' 
                                                ? 'bg-white text-black' 
                                                : 'bg-black text-white/80 border border-white/20 hover:bg-white/10'
                                            }`}
                                            onClick={() => {
                                                setActiveTab('albums');
                                                setSelectedItems([]);
                                            }}
                                        >
                                            Albums
                                        </button>
                                    </div>
                                    <input
                                        type="text"
                                        placeholder="Search..."
                                        className="w-full sm:w-auto px-4 py-2 text-sm rounded-lg border border-white/20 bg-black text-white placeholder-white/40 focus:outline-none focus:border-white/40"
                                        value={searchTerm}
                                        onChange={(e) => setSearchTerm(e.target.value)}
                                    />
                                </div>

                                <div className="overflow-x-auto table-container">
                                    <table className="min-w-full">
                                        <thead>
                                            <tr className="border-b border-white/10">
                                                <th className="text-left px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">#</th>
                                                <th 
                                                    className="text-left px-2 sm:px-4 py-2 text-xs sm:text-sm cursor-pointer hover:text-white text-white/80"
                                                    onClick={() => requestSort('title')}
                                                >
                                                    {activeTab === 'songs' ? 'Song' : 'Album'} Title
                                                    {getSortIndicator('title')}
                                                </th>
                                                {activeTab === 'songs' && (
                                                    <th 
                                                        className="text-left px-2 sm:px-4 py-2 text-xs sm:text-sm cursor-pointer hover:text-white text-white/80"
                                                        onClick={() => requestSort('album')}
                                                    >
                                                        Album{getSortIndicator('album')}
                                                    </th>
                                                )}
                                                {activeTab === 'albums' && (
                                                    <th className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">Tracks</th>
                                                )}
                                                <th 
                                                    className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm cursor-pointer hover:text-white text-white/80"
                                                    onClick={() => requestSort('streams')}
                                                >
                                                    Streams{getSortIndicator('streams')}
                                                </th>
                                                <th 
                                                    className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm cursor-pointer hover:text-white text-white/80"
                                                    onClick={() => requestSort('daily')}
                                                >
                                                    Daily{getSortIndicator('daily')}
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {filteredData[activeTab].map((item, index) => (
                                                <tr 
                                                    key={item.title + index} 
                                                    className={`${index % 2 === 0 ? 'bg-black' : 'bg-white/5'} cursor-pointer hover:bg-white/10`}
                                                    onClick={() => handleItemClick(item)}
                                                >
                                                    <td className="px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/60">{index + 1}</td>
                                                    <td className="px-2 sm:px-4 py-2 text-xs sm:text-sm text-white">{item.title}</td>
                                                    {activeTab === 'songs' && (
                                                        <td className="px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/60">{item.album}</td>
                                                    )}
                                                    {activeTab === 'albums' && (
                                                        <td className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">{item.tracks}</td>
                                                    )}
                                                    <td className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">{formatNumber(item.streams)}</td>
                                                    <td className="text-right px-2 sm:px-4 py-2 text-xs sm:text-sm text-white/80">{formatNumber(item.daily)}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>

                                {selectedItems.length > 0 && (
                                    <ComparisonChart 
                                        itemKeys={selectedItems} 
                                        itemsData={activeTab === 'songs' ? songs : albums}
                                        historyData={activeTab === 'songs' ? historyData : albumHistoryData}
                                        isAlbum={activeTab === 'albums'}
                                        onClose={() => setSelectedItems([])}
                                    />
                                )}
                            </>
                        )}
                    </div>
                </div>
            );
        };

        window.onload = function() {
            if (typeof ReactDOM !== 'undefined' && typeof React !== 'undefined') {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(<YeatStats />);
            } else {
                console.error('ReactDOM or React is not loaded.');
            }
        };
    </script>
</body>
</html>
